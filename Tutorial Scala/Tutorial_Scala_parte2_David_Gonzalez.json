{"paragraphs":[{"text":"val baseDir=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/03_rdd_notebook\"\nprint(\"\"\"%html\n<center>\n    <h1>ProgramaciÃ³n Distribuida sobre Grandes VolÃºmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de MatemÃ¡tica AstronomÃ­a FÃ­sica y ComputaciÃ³n\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de CÃ³rdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> DamiÃ¡n Barsotti - Ezequiel Orbe </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n\"\"\")\n","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/scala","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<center>\n    <h1>ProgramaciÃ³n Distribuida sobre Grandes VolÃºmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de MatemÃ¡tica AstronomÃ­a FÃ­sica y ComputaciÃ³n\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de CÃ³rdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> DamiÃ¡n Barsotti - Ezequiel Orbe </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n"}]},"apps":[],"jobName":"paragraph_1503165523067_-179457576","id":"20160818-202628_810221159","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:4462"},{"text":"%md #Tutorial Scala (parte 2)\n\nEste tutorial de Scala ayudarÃ¡ a entender los conceptos bÃ¡sicos para programar en este lenguaje.\nSe presentarÃ¡n los temas con la posibilidad de ejecutar y modificar los ejemplos en la misma pÃ¡gina de lectura para que pruebe y se familiarice con el lenguaje.","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Tutorial Scala (parte 2)</h1>\n<p>Este tutorial de Scala ayudarÃ¡ a entender los conceptos bÃ¡sicos para programar en este lenguaje.\n<br  />Se presentarÃ¡n los temas con la posibilidad de ejecutar y modificar los ejemplos en la misma pÃ¡gina de lectura para que pruebe y se familiarice con el lenguaje.</p>\n"}]},"apps":[],"jobName":"paragraph_1503165523068_-181381320","id":"20160818-202628_1132276461","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4463"},{"text":"%md ##Pattern Matching","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Pattern Matching</h2>\n"}]},"apps":[],"jobName":"paragraph_1503165523068_-181381320","id":"20160818-202628_880601097","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4464"},{"text":"%md Si usted conoce el lenguage Haskell siguiente ejemplo le resultarÃ¡ familiar.\nSi usted conoce lenguages imperativo como C o Java esta construcciÃ³n es parecida a las sentencias `switch` con algunas diferencias:\n* La palabra clave `match` se escribe despuÃ©s de la variable (`selection match`) a diferencia de `switch selection` en los otros lenguajes.\n* No hace falta la sentencia `break`.\n* El caso por defecto es `case _` o `case x` donde `x` es cualquier identificador que comience con minÃºscula.\n\nPara mÃ¡s informaciÃ³n ver\n* [Pattern Matching](http://docs.scala-lang.org/tutorials/tour/pattern-matching.html).","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":6,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>Si usted conoce el lenguage Haskell siguiente ejemplo le resultarÃ¡ familiar.\n<br  />Si usted conoce lenguages imperativo como C o Java esta construcciÃ³n es parecida a las sentencias <code>switch</code> con algunas diferencias:</p>\n<ul>\n<li>La palabra clave <code>match</code> se escribe despuÃ©s de la variable (<code>selection match</code>) a diferencia de <code>switch selection</code> en los otros lenguajes.</li>\n<li>No hace falta la sentencia <code>break</code>.</li>\n<li>El caso por defecto es <code>case _</code> o <code>case x</code> donde <code>x</code> es cualquier identificador que comience con minÃºscula.</li>\n</ul>\n<p>Para mÃ¡s informaciÃ³n ver</p>\n<ul>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/pattern-matching.html\">Pattern Matching</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523068_-181381320","id":"20160818-202628_959460339","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4465"},{"text":"val selection = \"Uno\"  \nselection match {  \n  case \"Uno\" => println(\"SeleccionÃ³ la opciÃ³n Uno!\")  \n  case \"Dos\" => println(\"SeleccionÃ³ la opciÃ³n Dos!\")  \n  case _ => println(\"SeleccionÃ³ otra cosa\")  \n}  ","dateUpdated":"2017-08-19T14:58:55-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523069_-181766069","id":"20160818-202628_1592675188","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4466","user":"anonymous","dateFinished":"2017-08-19T14:58:56-0300","dateStarted":"2017-08-19T14:58:56-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nselection: String = Uno\nSeleccionÃ³ la opciÃ³n Uno!\n"}]}},{"text":"%md ## CurrificaciÃ³n","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>CurrificaciÃ³n</h2>\n"}]},"apps":[],"jobName":"paragraph_1503165523069_-181766069","id":"20160818-202628_1953376262","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4467"},{"text":"%md &nbsp;\n\nLa currificaciÃ³n es una forma de definir funciones muy utilizada en los lenguajes funcionales.\nConsiste en definir sus parÃ¡metros de forma separada lo que permite usar la funciÃ³n predefiniendo parÃ¡metros.","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":6,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<p>La currificaciÃ³n es una forma de definir funciones muy utilizada en los lenguajes funcionales.\n<br  />Consiste en definir sus parÃ¡metros de forma separada lo que permite usar la funciÃ³n predefiniendo parÃ¡metros.</p>\n"}]},"apps":[],"jobName":"paragraph_1503165523070_-180611822","id":"20160818-202628_654420514","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4468"},{"text":"def madd(x:Int,y:Int) = x+y // mÃ©todo \ndef madd_curry (x:Int)(y:Int) = x + y // mÃ©todo con currificaciÃ³n\nval fadd = (x:Int, y:Int) => x + y // funciÃ³n\nval fadd_curry = (x:Int) => (y:Int) => x + y // funciÃ³n con currificaciÃ³n\n\n// funciÃ³n que aplica una funciÃ³n \ndef aplicar(f: Int => Int, x : Int) = f(x)\n\naplicar(madd_curry(1),10)\naplicar(fadd_curry(1),10)\n\n// La siguiente funcion currifica funciones\nval curry = (f:(Int,Int) => Int) => (a : Int) => (b:Int) => f (a,b)\nval sumar = (x:Int,y:Int) => x+y\nval sumar_curry = curry (sumar)\nsumar_curry (1) (4)\n\ndef curry[A] (f:(A,A) => A) (a : A) (b : A) = f (a,b)\nval sumar1 = curry (sumar) (1) _ // funciÃ³n  de tipo Int => Int que suma 1\nsumar1(7)","dateUpdated":"2017-08-19T15:05:11-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523070_-180611822","id":"20160818-202628_521583258","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4469","user":"anonymous","dateFinished":"2017-08-19T15:05:13-0300","dateStarted":"2017-08-19T15:05:12-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nmadd: (x: Int, y: Int)Int\n\nmadd_curry: (x: Int)(y: Int)Int\n\nfadd: (Int, Int) => Int = <function2>\n\nfadd_curry: Int => (Int => Int) = <function1>\n\naplicar: (f: Int => Int, x: Int)Int\n\nres85: Int = 11\n\nres86: Int = 11\n\ncurry: ((Int, Int) => Int) => (Int => (Int => Int)) = <function1>\n\nsumar: (Int, Int) => Int = <function2>\n\nsumar_curry: Int => (Int => Int) = <function1>\n\nres89: Int = 5\n\ncurry: [A](f: (A, A) => A)(a: A)(b: A)A\n\nsumar1: Int => Int = <function1>\n\nres91: Int = 8\n"}]}},{"text":"%md ##Colecciones","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Colecciones</h2>\n"}]},"apps":[],"jobName":"paragraph_1503165523070_-180611822","id":"20160818-202628_865069031","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4470"},{"title":"Arrays","text":"%md &nbsp;\n* Los arreglos se construyen con `Array(element1, element2, ...)`.\n* Internamente los arreglos en Scala son los arreglos primitivos de Java (`Array[Int]` en Scala es `int[]` de Java, `Array[String]` es `String[]` de Java, etc.).\n* Los arreglos son mutables (pueden modificar sus elementos aunque no su tamaÃ±o).\n* Para imprimirlos se puede usar su mÃ©todo `mkString` (ver ejemplo).\n* Los elementos de un arreglo pueden ser de cualquier tipo, pero el tipo final es la superclase comÃºn mÃ¡s cercana:\n```scala\n  class Foo(val value1:Int)\n  class Bar(value1:Int, val value2:Int) extends Foo(value1)\n  val list:Array[Foo] = Array(new Foo(1), new Bar(2,3))\n```\n\nPara mas informaciÃ³n sobre ver: \n* [DocumentaciÃ³n Scala sobre arreglos](http://www.scala-lang.org/api/current/index.html#scala.Array).","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<ul>\n<li>Los arreglos se construyen con <code>Array(element1, element2, ...)</code>.</li>\n<li>Internamente los arreglos en Scala son los arreglos primitivos de Java (<code>Array[Int]</code> en Scala es <code>int[]</code> de Java, <code>Array[String]</code> es <code>String[]</code> de Java, etc.).</li>\n<li>Los arreglos son mutables (pueden modificar sus elementos aunque no su tamaÃ±o).</li>\n<li>Para imprimirlos se puede usar su mÃ©todo <code>mkString</code> (ver ejemplo).</li>\n<li>Los elementos de un arreglo pueden ser de cualquier tipo, pero el tipo final es la superclase comÃºn mÃ¡s cercana:<pre><code class=\"scala\">class Foo(val value1:Int)\nclass Bar(value1:Int, val value2:Int) extends Foo(value1)\nval list:Array[Foo] = Array(new Foo(1), new Bar(2,3))\n</code></pre>\n</li>\n</ul>\n<p>Para mas informaciÃ³n sobre ver:</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.Array\">DocumentaciÃ³n Scala sobre arreglos</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523071_-180996571","id":"20160818-202628_908384136","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4471"},{"title":"Arrays","text":"def printArray[K](array:Array[K]) = array.mkString(\"Array(\" , \", \" , \")\")  \n\n//Arreglo de tipo Array[Int]  \nval array1 = Array(1, 2, 3)  \nprintArray(array1)//>Array(1, 2, 3)\n\n//Arreglo de tipo Array[String]  \nval array2 = Array(\"a\", \"b\", \"c\")\nprintArray(array2)  //>Array(a, b, c)  \n\n//Los valores se acceden con (index) no [index]    \nval itemAtIndex0 = array2(0)   //>itemAtIndex0 = a\n\n//de igual manera se modifican    \narray2(0) = \"d\"    \nprintArray(array2)  //>Array(d, b, c)  \n\n//Arreglo de tipo Array[Any]  \nval array3 = Array(\"a\", 2, true)\nprintArray(array3)//>Array(a, 2, true)  ","dateUpdated":"2017-08-19T15:06:20-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523071_-180996571","id":"20160818-202628_484322260","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4472","user":"anonymous","dateFinished":"2017-08-19T15:06:21-0300","dateStarted":"2017-08-19T15:06:20-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nprintArray: [K](array: Array[K])String\n\narray1: Array[Int] = Array(1, 2, 3)\n\nres94: String = Array(1, 2, 3)\n\narray2: Array[String] = Array(a, b, c)\n\nres97: String = Array(a, b, c)\n\nitemAtIndex0: String = a\n\nres103: String = Array(d, b, c)\n\narray3: Array[Any] = Array(a, 2, true)\n\nres106: String = Array(a, 2, true)\n"}]}},{"title":"Operaciones sobre Arrays","text":"val (array1,array3) = (Array(1, 2, 3),Array(\"a\", 2, true))\n//Para concatenar dos arreglos se usa el operador ++\n//Para agregar adelante se usa +: y atrÃ¡s :+    \nval concatenated = \"adelante\" +: (array1 ++ array3) :+ \"atrÃ¡s\"\nprintArray(concatenated)  //>Array(adelante 1, 2, 3, a, 2, true, atrÃ¡s)  \n\n//Para encontrar la posiciÃ³n de un elemento:\narray3.indexOf(2) //>1  \n\n//BÃºsqueda\nval personArray = Array((\"Pedro\",1), (\"Kuka\",2), (\"Porota\",3))\ndef findByName(name:String) = personArray.find(_._1 == name).getOrElse((\"Lucas\",4))  //>findByName(name = \"foo\") => (Lucas,4)  \nval findPedro = findByName(\"Pedro\")  //>finPedro = (Pedro,2)  \nval findMaria = findByName(\"Maria\")  //>findMaria = (Lucas,4)  \n\nval pedroFound = findPedro._2  //>pedroFound = 1  \nval mariaFound = findMaria._2  //>mariaFound = 4  \n\n// SubstracciÃ³n\nval diffArray = Array(1,2,3,4).diff(Array(3,1))\nprintArray(diffArray) //>Array(2, 4) ","dateUpdated":"2017-08-19T15:06:30-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523072_-96736562","id":"20160818-202628_1782769927","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4473","user":"anonymous","dateFinished":"2017-08-19T15:06:32-0300","dateStarted":"2017-08-19T15:06:30-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\narray1: Array[Int] = Array(1, 2, 3)\narray3: Array[Any] = Array(a, 2, true)\n\nconcatenated: Array[Any] = Array(adelante, 1, 2, 3, a, 2, true, atrÃ¡s)\n\nres109: String = Array(adelante, 1, 2, 3, a, 2, true, atrÃ¡s)\n\nres112: Int = 1\n\npersonArray: Array[(String, Int)] = Array((Pedro,1), (Kuka,2), (Porota,3))\n\nfindByName: (name: String)(String, Int)\n\nfindPedro: (String, Int) = (Pedro,1)\n\nfindMaria: (String, Int) = (Lucas,4)\n\npedroFound: Int = 1\n\nmariaFound: Int = 4\n\ndiffArray: Array[Int] = Array(2, 4)\n\nres118: String = Array(2, 4)\n"}]}},{"title":"Listas","text":"%md\n\n* Las listas se construyen con `List(element1, element2, ...)`.\n* Los tipos de sus elementos pueden ser de cualquier tipo, pero el tipo final es la superclase comÃºn mÃ¡s cercana:\n```scala\n  class Foo(val value1:Int)\n  class Bar(value1:Int, val value2:Int) extends Foo(value1)\n  val list:List[Foo] = List(new Foo(1), new Bar(2,3))\n```\n* Las listas por defecto son **inmutables** (cualquier cambio crea una lista nueva, dejando la original tal cual). En el ejemplo siguiente se muestra como crear una mutable.\n* EstÃ¡n implementadas con listas ligadas por lo que agregar un elemento se hace a tiempo constante pero el acceso a un elemento es lineal.\n*  Se pueden concatenar listas mutables con inmutables, devolviendo el tipo inmutable. \n\nPara mÃ¡s informaciÃ³n ver: \n* [DocumentaciÃ³n Scala sobre listas](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List).","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<ul>\n<li>Las listas se construyen con <code>List(element1, element2, ...)</code>.</li>\n<li>Los tipos de sus elementos pueden ser de cualquier tipo, pero el tipo final es la superclase comÃºn mÃ¡s cercana:<pre><code class=\"scala\">class Foo(val value1:Int)\nclass Bar(value1:Int, val value2:Int) extends Foo(value1)\nval list:List[Foo] = List(new Foo(1), new Bar(2,3))\n</code></pre>\n</li>\n<li>Las listas por defecto son <strong>inmutables</strong> (cualquier cambio crea una lista nueva, dejando la original tal cual). En el ejemplo siguiente se muestra como crear una mutable.</li>\n<li>EstÃ¡n implementadas con listas ligadas por lo que agregar un elemento se hace a tiempo constante pero el acceso a un elemento es lineal.</li>\n<li>Se pueden concatenar listas mutables con inmutables, devolviendo el tipo inmutable.</li>\n</ul>\n<p>Para mÃ¡s informaciÃ³n ver:</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List\">DocumentaciÃ³n Scala sobre listas</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523072_-96736562","id":"20160818-202628_94254130","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4474"},{"title":"Listas","text":"//Listas inmutable con tipo List[Int]  \nval list1 = List(1, 2, 3) //> list1 = List(1, 2, 3)  \n//Listas inmutable con tipo List[Any]  \nval list2 = List(\"a\", 2, true) //> list2 = List(a, 2, true)  \nimport collection.mutable   \n//Listas mutables\nval mlist = mutable.ListBuffer(\"a\", \"b\", \"c\")  \n\n//Se accede con (indice) no [indice]   \nval firstItem = list1(0) //> firstItem = 1  \n\n//Se modifican sus valores de la misma forma (sulo listas mutables)    \nmlist(0) = \"d\"    \nmlist //> ArrayBuffer(d, b, c)","dateUpdated":"2017-08-19T15:08:48-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523072_-96736562","id":"20160818-202628_682874273","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4475","user":"anonymous","dateFinished":"2017-08-19T15:08:49-0300","dateStarted":"2017-08-19T15:08:48-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nlist1: List[Int] = List(1, 2, 3)\n\nlist2: List[Any] = List(a, 2, true)\n\nimport collection.mutable\n\nmlist: scala.collection.mutable.ListBuffer[String] = ListBuffer(a, b, c)\n\nfirstItem: Int = 1\n\nres127: scala.collection.mutable.ListBuffer[String] = ListBuffer(d, b, c)\n"}]}},{"title":"Operaciones sobre Listas","text":"val (list1,list2) = (List(1, 2, 3),List(\"a\", 2, true))\n\n//Concatenacion con el operador ++ o ::: (solo listas)  \nlist1 ++ list2 //> List(1, 2, 3, a, 2, true)  \nlist1 ::: list2 //> List(1, 2, 3, a, 2, true)  \n\n//Para insertar adelante se usa :: (solo listas) or +:  \n0 :: list1 //> List(0, 1, 2, 3)  \n0 +: list1 //> List(0, 1, 2, 3)  \n\n//Para insertar atrÃ¡s se usa :+ (poco eficiente para listas inmutables)  \nlist1 :+ 4 //> List(1, 2, 3, 4)  \n\nimport collection.mutable\nval mlist = mutable.ListBuffer(\"d\", \"b\", \"c\")\n//Todo junto:  \nval concatenated = 1 :: list1 ::: list2 ++ mlist :+ 'd' //> concatenated = List(1, 1, 2, 3, a, 2, true, d, b, c, d)  \n//La concatenaciÃ³n no modifica las listas originales     \nlist1 //> List(1, 2, 3) ","dateUpdated":"2017-08-19T15:08:53-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523073_-97121311","id":"20160818-202628_1495316381","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4476","user":"anonymous","dateFinished":"2017-08-19T15:08:54-0300","dateStarted":"2017-08-19T15:08:53-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\nlist1: List[Int] = List(1, 2, 3)\nlist2: List[Any] = List(a, 2, true)\n\nres130: List[Any] = List(1, 2, 3, a, 2, true)\n\nres131: List[Any] = List(1, 2, 3, a, 2, true)\n\nres134: List[Int] = List(0, 1, 2, 3)\n\nres135: List[Int] = List(0, 1, 2, 3)\n\nres138: List[Int] = List(1, 2, 3, 4)\n\nimport collection.mutable\n\nmlist: scala.collection.mutable.ListBuffer[String] = ListBuffer(d, b, c)\n\nconcatenated: List[Any] = List(1, 1, 2, 3, a, 2, true, d, b, c, d)\n\nres142: List[Int] = List(1, 2, 3)\n"}]}},{"title":"Operaciones Sobre Listas","text":"val (list1,list2) = (List(1, 2, 3),List(\"a\", 2, true))\nimport collection.mutable\nval mlist = mutable.ArrayBuffer(\"d\", \"b\", \"c\", \"f\")\n\n//EliminaciÃ³n de elementos (solo listas mutables y crea una nueva):  \n//crea un arreglo nuevo con la \"c\" eliminada, mlist queda igual  \nmlist - \"c\" //> ArrayBuffer(d, b, f)  \n//crea un nuevo arreglo con e, f eliminados, mlist queda igual  \nmlist -- List(\"e\", \"f\") //> ArrayBuffer(d, b, c)  \n//mlist no se modifica  \nmlist //> ArrayBuffer(d, b, c)  \n\n//EliminaciÃ³n de elementos, la lista si cambia (solo mutables):   \n//elimina c de la lista  \nmlist -= \"c\" //> ArrayBuffer(d, b, e, f, g)  \n//elimina e and f  \nmlist --= List(\"e\", \"f\") //> ArrayBuffer(d, b, e, f, g)  \nmlist //> ArrayBuffer(d, b)  \n\n//Agregar elelmentos, la lista si cambia (solo mutables)   \nmlist += \"e\" //> ArrayBuffer(d, b, e)  \nmlist ++= List(\"f\", \"g\") //> ArrayBuffer(d, b, e, f, g)  \nmlist //ArrayBuffer(d, b, e, f, g) //> ArrayBuffer(d, b, e, f, g)  ","dateUpdated":"2017-08-19T15:10:43-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523073_-97121311","id":"20160818-202628_1871212485","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4477","user":"anonymous","dateFinished":"2017-08-19T15:10:44-0300","dateStarted":"2017-08-19T15:10:43-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\nlist1: List[Int] = List(1, 2, 3)\nlist2: List[Any] = List(a, 2, true)\n\nimport collection.mutable\n\nmlist: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, c, f)\n\nres146: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, f)\n\nres148: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, c)\n\nres150: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, c, f)\n\nres154: mlist.type = ArrayBuffer(d, b, f)\n\nres156: mlist.type = ArrayBuffer(d, b)\n\nres157: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b)\n\nres160: mlist.type = ArrayBuffer(d, b, e)\n\nres161: mlist.type = ArrayBuffer(d, b, e, f, g)\n\nres162: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(d, b, e, f, g)\n"}]}},{"title":"Operaciones sobre listas","text":"//Diff   \nval diffList = List(1,2,3,4) diff List(2,3) //> diffList = List(1, 4)  \n\nval personList = List((\"Pepe\",1), (\"Carlos\",2), (\"Kuka\",3))\n\n//BÃºsqueda (devuelve la primer apariciÃ³n)   \ndef findByName(name:String) = personList.find(_._1 == name).getOrElse((\"David\",4)) //> findByName(name = \"foo\") => (David,4)  \nval findPepe = findByName(\"Pepe\")  \nval findKuka = findByName(\"MarÃ­a\")  \n\nfindPepe._2 //> 1  \nfindKuka._2 //> 4","dateUpdated":"2017-08-19T15:11:05-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523074_-95967064","id":"20160818-202628_442695254","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4478","user":"anonymous","dateFinished":"2017-08-19T15:11:05-0300","dateStarted":"2017-08-19T15:11:05-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndiffList: List[Int] = List(1, 4)\n\npersonList: List[(String, Int)] = List((Pepe,1), (Carlos,2), (Kuka,3))\n\nfindByName: (name: String)(String, Int)\n\nfindPepe: (String, Int) = (Pepe,1)\n\nfindKuka: (String, Int) = (David,4)\n\nres168: Int = 1\n\nres169: Int = 4\n"}]}},{"title":"Sets","text":"%md\n* Los conjuntos se construyen con `Set(element1, element2, ...)`.\n* Pueden contener diferentes tipos. El tipo final es la superclase comun mÃ¡s cercana.\n* El tipo por defecto de los conjuntos es `Predef.Set` el cual es inmutable. En el ejemplo siguiente se muestra como crear uno mutable.\n* No admite duplicaciÃ³n de elementos. Al agregar uno que ya estaba se sobreescribe.\n\nPara mÃ¡s informaciÃ³n ver\n* [scala.Predef](http://www.scala-lang.org/api/current/index.html#scala.Predef$).\n* [DocumentaciÃ³n Scala sobre conjuntos](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Set).","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<ul>\n<li>Los conjuntos se construyen con <code>Set(element1, element2, ...)</code>.</li>\n<li>Pueden contener diferentes tipos. El tipo final es la superclase comun mÃ¡s cercana.</li>\n<li>El tipo por defecto de los conjuntos es <code>Predef.Set</code> el cual es inmutable. En el ejemplo siguiente se muestra como crear uno mutable.</li>\n<li>No admite duplicaciÃ³n de elementos. Al agregar uno que ya estaba se sobreescribe.</li>\n</ul>\n<p>Para mÃ¡s informaciÃ³n ver</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.Predef$\">scala.Predef</a>.</li>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Set\">DocumentaciÃ³n Scala sobre conjuntos</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523074_-95967064","id":"20160818-202628_846236849","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4479"},{"title":"Sets","text":"val set1 = Set(1, 2, 3) //Conjunto immutable de tipo Set[Int]  \nval set2 = Set(\"a\", 2, true) //Conjunto inmutable de tipo Set[Any]\n\nimport collection.mutable  \nval mset = mutable.HashSet(\"a\", \"b\", \"c\") // VersiÃ³n mutable de conjunto \n\n//No admite duplicados\nprintln(Set(1,2,3,2,4,3,2,1,2)) //Set(1, 2, 3, 4)  \n\n//Pertenece   \nval oneExists = set1(1)  \nval fourExists = set1(4)  \nprintln(oneExists) // true  \nprintln(fourExists) // false  \n// Se puede usar mset(\"a\") = false pero no es recomendado","dateUpdated":"2017-08-19T15:12:10-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":12,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523074_-95967064","id":"20160818-202628_514472829","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4480","user":"anonymous","dateFinished":"2017-08-19T15:12:11-0300","dateStarted":"2017-08-19T15:12:10-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nset1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\n\nset2: scala.collection.immutable.Set[Any] = Set(a, 2, true)\n\nimport collection.mutable\n\nmset: scala.collection.mutable.HashSet[String] = Set(c, a, b)\nSet(1, 2, 3, 4)\n\noneExists: Boolean = true\n\nfourExists: Boolean = false\ntrue\nfalse\n"}]}},{"title":"Operaciones sobre Sets","text":"val (set1,set2) = (Set(1, 2, 3),Set(\"a\", 2, true))\nimport collection.mutable  \nval mset = mutable.HashSet(\"a\", \"b\", \"c\")\n\n//ConcatenaciÃ³n (remueve duplicados)  \nval concatenated = set1 ++ set2 ++ mset\nprintln(concatenated) // Set(1, a, true, 2, b, 3, c)  \n//Concatenacion no modifica los conjuntos originales   \nprintln(set1) //Set(1, 2, 3)  \n\n// Se pueden eliminar elementos de los conjuntos mutables\nmset -= \"c\"  \nprintln (mset) //Set(\"b\")  \n// Se puede usar mset(\"a\") = false pero no es recomendado\n\n","dateUpdated":"2017-08-19T15:22:42-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523075_-96351813","id":"20160818-202628_322430640","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4481","user":"anonymous","dateFinished":"2017-08-19T15:22:43-0300","dateStarted":"2017-08-19T15:22:42-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\n\nset1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\nset2: scala.collection.immutable.Set[Any] = Set(a, 2, true)\n\nimport collection.mutable\n\nmset: scala.collection.mutable.HashSet[String] = Set(c, a, b)\n\nconcatenated: scala.collection.immutable.Set[Any] = Set(1, a, true, 2, b, 3, c)\nSet(1, a, true, 2, b, 3, c)\nSet(1, 2, 3)\n\nres255: mset.type = Set(a, b)\nSet(a, b)\n"}]}},{"title":"Operaciones sobre Sets","text":"//Agregar solo en conjuntos mutables  \nmset += \"e\"  \nmset ++= Set(\"f\", \"g\")  \n\nprintln (mset) //Set(f, g, e, b)  \n//Diff  \nval diffSet = Set(1,2,3,4) diff Set(2,3)  \nprintln(diffSet) // Set(1, 4)  \n\n//BÃºsqueda  \nval personSet = Set((\"Pepe\",1), (\"Carlos\",2), (\"Kuka\",3))  \ndef findByName(name:String) = personSet.find(_._1 == name).getOrElse((\"David\",4))  \nval findPepe = findByName(\"Pepe\")  \nval findKuka = findByName(\"Maria\")  \n\nprintln(findPepe._2) //1  \nprintln(findKuka._2) //4  \n// Para bÃºsqueda sobre claves es mejor usa Map (lo veremos mas adelante)","dateUpdated":"2017-08-19T15:20:28-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523075_-96351813","id":"20160818-202628_2147400601","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4482","user":"anonymous","dateFinished":"2017-08-19T15:20:29-0300","dateStarted":"2017-08-19T15:20:28-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres197: mset.type = Set(c, e, a, b)\n\nres198: mset.type = Set(f, c, g, e, a, b)\nSet(f, c, g, e, a, b)\n\ndiffSet: scala.collection.immutable.Set[Int] = Set(1, 4)\nSet(1, 4)\n\npersonSet: scala.collection.immutable.Set[(String, Int)] = Set((Pepe,1), (Carlos,2), (Kuka,3))\n\nfindByName: (name: String)(String, Int)\n\nfindPepe: (String, Int) = (Pepe,1)\n\nfindKuka: (String, Int) = (David,4)\n1\n4\n"}]}},{"title":"Maps","text":"%md &nbsp;\n* Los *Maps* se construyen con `Map(key1 -> value1, key2 -> value2, ...)`\n* Pueden almacenar diferentes tipos, pero el tipo final de las claves/valores serÃ¡n la superclase comÃºn mÃ¡s cercana.\n* El `Map` por defecto (`Predef.Map`) es inmutable.\n* No se pueden tener claves duplicadas. Si se agrega un par clave/valor que ya existe se sobreescribe.\n\nVer tambiÃ©n:\n* [scala.Predef](http://www.scala-lang.org/api/current/index.html#scala.Predef$).\n* [DocumentaciÃ³n Scala sobre maps](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map).","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<ul>\n<li>Los <em>Maps</em> se construyen con <code>Map(key1 -&gt; value1, key2 -&gt; value2, ...)</code></li>\n<li>Pueden almacenar diferentes tipos, pero el tipo final de las claves/valores serÃ¡n la superclase comÃºn mÃ¡s cercana.</li>\n<li>El <code>Map</code> por defecto (<code>Predef.Map</code>) es inmutable.</li>\n<li>No se pueden tener claves duplicadas. Si se agrega un par clave/valor que ya existe se sobreescribe.</li>\n</ul>\n<p>Ver tambiÃ©n:</p>\n<ul>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.Predef$\">scala.Predef</a>.</li>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map\">DocumentaciÃ³n Scala sobre maps</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523076_-98275558","id":"20160818-202628_107159126","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4483"},{"title":"Maps","text":"val map = Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)   \n//Map de tipo Map[String, Int]  \n\n//Maps elimina duplicados de las claves:  \nprintln(Map(\"a\" -> 1, \"a\" -> 2)) //Map(a -> 2)  \n\n//Tomar un elemento segÃºn clave usando map(key)   \nval one = map(\"one\")  \nprintln(one) // 1 \n\n// Si la clave no existe lanza la exceptcion NoSuchElementException\n//val four = map(\"four\")\n// Hay que usar el mÃ©todo get que devuelve una Option (se explicarÃ¡ despuÃ©s)\nval fourExistsOption = map.get(\"four\")  \nprintln(fourExistsOption.isDefined) // false\nprintln(fourExistsOption)","dateUpdated":"2017-08-19T15:21:10-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":12,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523076_-98275558","id":"20160818-202628_718105164","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4484","user":"anonymous","dateFinished":"2017-08-19T15:21:10-0300","dateStarted":"2017-08-19T15:21:10-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nmap: scala.collection.immutable.Map[String,Int] = Map(one -> 1, two -> 2, three -> 3)\nMap(a -> 2)\n\none: Int = 1\n1\n\nfourExistsOption: Option[Int] = None\nfalse\nNone\n"}]}},{"title":"Operaciones sobre maps","text":"import collection.mutable  \nval mmap = mutable.HashMap(\"a\" -> 1, \"b\" -> 2 , \"c\" -> 3)   \n//la versiÃ³n mutable del Map  \n\n//Se pueden agregar o modificar elementos con:\nmmap(\"d\") = 4   \nprintln(mmap) //Map(b -> 2, d -> 4, a -> 1, c -> 3)  \n\nval (map1,map2) = (Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3), Map(1 -> \"one\", \"2\" -> 2.0, 3.0 -> false))   \n// map 1 es de tipo Map[String,Int] y map2 es de tipo Map[Any,Any]\n\n//ConcatenaciÃ³n con ++   \n//(elimina duplicados, no mantiene el orde)  \nval concatenated = map1 ++ map2 ++ mmap\nprintln(concatenated)   \n// Map(three -> 3, 1 -> one, two -> 2, a -> 1, b -> 2, 3.0 -> false, 2 -> 2.0, c -> 3, one -> 1, d -> 4)  \n//ConcatenaciÃ³n no modifica los maps originales   \nprintln(map1) //Map(one -> 1, two -> 2, three -> 3) ","dateUpdated":"2017-08-19T15:21:53-0300","config":{"enabled":true,"title":true,"tableHide":false,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523077_-98660307","id":"20160818-202628_543506175","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4485","user":"anonymous","dateFinished":"2017-08-19T15:21:53-0300","dateStarted":"2017-08-19T15:21:53-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport collection.mutable\n\nmmap: scala.collection.mutable.HashMap[String,Int] = Map(b -> 2, a -> 1, c -> 3)\nMap(b -> 2, d -> 4, a -> 1, c -> 3)\n\n\nmap1: scala.collection.immutable.Map[String,Int] = Map(one -> 1, two -> 2, three -> 3)\nmap2: scala.collection.immutable.Map[Any,Any] = Map(1 -> one, 2 -> 2.0, 3.0 -> false)\n\nconcatenated: scala.collection.immutable.Map[Any,Any] = Map(three -> 3, 1 -> one, two -> 2, a -> 1, b -> 2, 3.0 -> false, 2 -> 2.0, c -> 3, one -> 1, d -> 4)\nMap(three -> 3, 1 -> one, two -> 2, a -> 1, b -> 2, 3.0 -> false, 2 -> 2.0, c -> 3, one -> 1, d -> 4)\nMap(one -> 1, two -> 2, three -> 3)\n"}]}},{"title":"Operaciones sobre maps","text":"import collection.mutable  \nval mmap = mutable.HashMap(\"a\" -> 1, \"b\" -> 2 , \"c\" -> 3) \n\n//Removing elements (mutable Sets only)  \nmmap -= \"c\"  \nprintln (mmap) //Map(b -> 2, a -> 1)  \n\n//Adding elements (mutable Lists only)  \nmmap += \"e\" -> 5  \nmmap ++= Map(\"f\" -> 6, \"g\" -> 7)  \nprintln (mmap) //Map(e -> 5, b -> 2, g -> 7, a -> 1, f -> 6)\n\n//BÃºsqueda  \nval personMap = Map((\"Pepe\",1), (\"Carlos\",2), (\"Kuka\",3))  \ndef findByName(name:String) = personSet.find(_._1 == name).getOrElse((\"David\",4))  \nval findPepe = findByName(\"Pepe\")  \nval findKuka = findByName(\"Maria\")  \n\nprintln(findPepe._2) //1  \nprintln(findKuka._2) //4  ","dateUpdated":"2017-08-19T15:23:19-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523077_-98660307","id":"20160818-202628_70411293","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4486","user":"anonymous","dateFinished":"2017-08-19T15:23:20-0300","dateStarted":"2017-08-19T15:23:19-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport collection.mutable\n\nmmap: scala.collection.mutable.HashMap[String,Int] = Map(b -> 2, a -> 1, c -> 3)\n\nres261: mmap.type = Map(b -> 2, a -> 1)\nMap(b -> 2, a -> 1)\n\nres265: mmap.type = Map(e -> 5, b -> 2, a -> 1)\n\nres266: mmap.type = Map(e -> 5, b -> 2, g -> 7, a -> 1, f -> 6)\nMap(e -> 5, b -> 2, g -> 7, a -> 1, f -> 6)\n\npersonMap: scala.collection.immutable.Map[String,Int] = Map(Pepe -> 1, Carlos -> 2, Kuka -> 3)\n\nfindByName: (name: String)(String, Int)\n\nfindPepe: (String, Int) = (Pepe,1)\n\nfindKuka: (String, Int) = (David,4)\n1\n4\n"}]}},{"text":"%md ## Contenedores Mutables","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Contenedores Mutables</h2>\n"}]},"apps":[],"jobName":"paragraph_1503165523077_-98660307","id":"20160818-202628_440224611","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4487"},{"title":"Contenedores Mutables","text":"%md &nbsp;\nScala promueve el uso de contenedores inmutables como `List`, `Set` y `Map`. De todas maneras, hay veces que se necesitan las versiones mutables por cuestiones de eficiencia.\n\nComo ya vimos Scala provee las versiones mutables de los contenedores en `scala.colections.mutable`:\n\n* `ListBuffer` es la versiÃ³n mutables de `List`. \n   EstÃ¡n implementadas con listas ligadas: al igual que `List`, agregar un elemento al principio o al final se hace a tiempo constante y el acceso a un elemento es a tiempo lineal.\n* `arrayBuffer` es otra versiÃ³n mutable de `List`. \n  La diferencia con la anterior es que se implementa con arreglos: el acceso es a tiempo constante pero agregar un elemento al principio o al final es lineal.\n* `hashSet` es la versiÃ³n mutable de `Set`.\n* `hashMap` es la versiÃ³n mutable de `Map`.\n   Estas dÃ³s Ãºltimas tienen acceso y agregado constantes (casi siempre, se impelemntan con tablas hash).\n\nEs buena prÃ¡ctica de programaciÃ³n es agregar la palabra `mutable.` cuando se crean los contenedores, como muestra el ejemplo siguiente. \n\n---\n\n* Los contenedores mutables permiten agregar y borrar valores sin necesidad de hacer copia de todo el objeto.\n* Las asignaciones a si mismo `+=`, `++=`, `-=`, `--=` son mÃ©todos de todos los contenedores mutable.\nPara mÃ¡s informaciÃ³n ver:\n* [BufferLike](http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.BufferLike)","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":6,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;\n<br  />Scala promueve el uso de contenedores inmutables como <code>List</code>, <code>Set</code> y <code>Map</code>. De todas maneras, hay veces que se necesitan las versiones mutables por cuestiones de eficiencia.</p>\n<p>Como ya vimos Scala provee las versiones mutables de los contenedores en <code>scala.colections.mutable</code>:</p>\n<ul>\n<li><code>ListBuffer</code> es la versiÃ³n mutables de <code>List</code>.\n<br  />EstÃ¡n implementadas con listas ligadas: al igual que <code>List</code>, agregar un elemento al principio o al final se hace a tiempo constante y el acceso a un elemento es a tiempo lineal.</li>\n<li><code>arrayBuffer</code> es otra versiÃ³n mutable de <code>List</code>.\n<br  />La diferencia con la anterior es que se implementa con arreglos: el acceso es a tiempo constante pero agregar un elemento al principio o al final es lineal.</li>\n<li><code>hashSet</code> es la versiÃ³n mutable de <code>Set</code>.</li>\n<li><code>hashMap</code> es la versiÃ³n mutable de <code>Map</code>.\n<br  />Estas dÃ³s Ãºltimas tienen acceso y agregado constantes (casi siempre, se impelemntan con tablas hash).</li>\n</ul>\n<p>Es buena prÃ¡ctica de programaciÃ³n es agregar la palabra <code>mutable.</code> cuando se crean los contenedores, como muestra el ejemplo siguiente.</p>\n<hr />\n<ul>\n<li>Los contenedores mutables permiten agregar y borrar valores sin necesidad de hacer copia de todo el objeto.</li>\n<li>Las asignaciones a si mismo <code>+=</code>, <code>++=</code>, <code>-=</code>, <code>--=</code> son mÃ©todos de todos los contenedores mutable.\n<br  />Para mÃ¡s informaciÃ³n ver:</li>\n<li><a href=\"http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.BufferLike\">BufferLike</a></li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523078_-97506060","id":"20160818-202628_1541660002","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4488"},{"title":"Contenedores Mutables","text":"import scala.collection.mutable  \n\nval arrayBuffer = mutable.ArrayBuffer(1, 2, 3)   \nval listBuffer = mutable.ListBuffer(\"a\", \"b\", \"c\")  \nval hashSet = mutable.Set(0.1, 0.2, 0.3)  \nval hashMap = mutable.Map(\"one\" -> 1, \"two\" -> 2)  ","dateUpdated":"2017-08-19T17:12:36-0300","config":{"enabled":true,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"colWidth":6,"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\narrayBuffer: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)\n\nlistBuffer: scala.collection.mutable.ListBuffer[String] = ListBuffer(a, b, c)\n\nhashSet: scala.collection.mutable.Set[Double] = Set(0.3, 0.2, 0.1)\n\nhashMap: scala.collection.mutable.Map[String,Int] = Map(one -> 1, two -> 2)\n"}]},"apps":[],"jobName":"paragraph_1503165523078_-97506060","id":"20160818-202628_1392017959","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4489","user":"anonymous","dateFinished":"2017-08-19T17:12:36-0300","dateStarted":"2017-08-19T17:12:36-0300"},{"title":"Contenedores Mutables","text":"import scala.collection.mutable  \n\nval arrayBuffer = mutable.ArrayBuffer(1, 2, 3)   \nval listBuffer = mutable.ListBuffer(\"a\", \"b\", \"c\")  \nval hashMap = mutable.Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)  \n\narrayBuffer += 4  \nlistBuffer += \"d\"  \narrayBuffer -= 1  \nlistBuffer -= \"a\"  \nhashMap += \"four\" -> 4  \nhashMap -= \"one\"  \n\narrayBuffer ++= List(5, 6, 7)  \nhashMap ++= Map(\"five\" -> 5, \"six\" -> 6)  \nhashMap --= Set(\"one\", \"three\")  \n\n\nprintln(arrayBuffer)  \nprintln(listBuffer)  \nprintln(hashMap)  ","dateUpdated":"2017-08-19T17:12:44-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":6,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523079_-97890809","id":"20160818-202628_1881598052","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4490","user":"anonymous","dateFinished":"2017-08-19T17:12:46-0300","dateStarted":"2017-08-19T17:12:44-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\narrayBuffer: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)\n\nlistBuffer: scala.collection.mutable.ListBuffer[String] = ListBuffer(a, b, c)\n\nhashMap: scala.collection.mutable.Map[String,Int] = Map(one -> 1, three -> 3, two -> 2)\n\nres276: arrayBuffer.type = ArrayBuffer(1, 2, 3, 4)\n\nres277: listBuffer.type = ListBuffer(a, b, c, d)\n\nres278: arrayBuffer.type = ArrayBuffer(2, 3, 4)\n\nres279: listBuffer.type = ListBuffer(b, c, d)\n\nres280: hashMap.type = Map(one -> 1, three -> 3, four -> 4, two -> 2)\n\nres281: hashMap.type = Map(three -> 3, four -> 4, two -> 2)\n\nres283: arrayBuffer.type = ArrayBuffer(2, 3, 4, 5, 6, 7)\n\nres284: hashMap.type = Map(three -> 3, six -> 6, four -> 4, five -> 5, two -> 2)\n\nres285: hashMap.type = Map(six -> 6, four -> 4, five -> 5, two -> 2)\nArrayBuffer(2, 3, 4, 5, 6, 7)\nListBuffer(b, c, d)\nMap(six -> 6, four -> 4, five -> 5, two -> 2)\n"}]}},{"title":"Contenedores Inmutables con VAR","text":"%md Una observaciÃ³n mÃ¡s con `+=`, `++=`, `-=`, `-== `:\n* Para contenedores inmutables - no tienen estos mÃ©todos, pero si los declaramos con `var` en vez de `val` el compilador lo expande a `variable = variable op param` (ver el ejemplo).\n* Para contenedores mutables - son mÃ©todos del contenedor y lo modifican.","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"title":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":6,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>Una observaciÃ³n mÃ¡s con <code>+=</code>, <code>++=</code>, <code>-=</code>, <code>-==</code>:</p>\n<ul>\n<li>Para contenedores inmutables - no tienen estos mÃ©todos, pero si los declaramos con <code>var</code> en vez de <code>val</code> el compilador lo expande a <code>variable = variable op param</code> (ver el ejemplo).</li>\n<li>Para contenedores mutables - son mÃ©todos del contenedor y lo modifican.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523079_-97890809","id":"20160818-202628_1262370177","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4491"},{"title":"Contenedores Inmutables con VAR","text":"import scala.collection.mutable  \n\nvar immutableSet = Set(1, 2, 3)   \n\nimmutableSet += 4   \n//es lo mismo que:  \nimmutableSet = immutableSet + 4  \n\n//para el caso mutable:\nval mutableSet = mutable.Set(1, 2, 3)    \n\nmutableSet += 4   \n// es lo mismo que:   \nmutableSet.+=(4)  \n\nprintln(immutableSet, mutableSet)  ","dateUpdated":"2017-08-19T17:13:53-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":6,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523079_-97890809","id":"20160818-202628_660742043","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4492","user":"anonymous","dateFinished":"2017-08-19T17:13:54-0300","dateStarted":"2017-08-19T17:13:53-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\nimmutableSet: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\n\nimmutableSet: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)\n\nmutableSet: scala.collection.mutable.Set[Int] = Set(1, 2, 3)\n\nres298: mutableSet.type = Set(1, 2, 3, 4)\n\nres300: mutableSet.type = Set(1, 2, 3, 4)\n(Set(1, 2, 3, 4),Set(1, 2, 3, 4))\n"}]}},{"text":"%md ## Clases","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Clases</h2>\n"}]},"apps":[],"jobName":"paragraph_1503165523080_-99814553","id":"20160818-202628_1614853851","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4493"},{"text":"%md &nbsp;\n* Las clases en Scala definen sus atributos con `val` (solo lectura) o `var` (lectura/escritura). \n* Los mÃ©todos se definen con `def` en la forma que ya vimos.\n* Notar en el ejemplo que el acceso a los atributos y mÃ©todos es uniforme lo que permite cambiar la implementaciÃ³n sin cambiar el cÃ³digo que lo usa<sup>1</sup>.\n* Para declarar metodos o variables privadas se antepone la palabra clave `private` (ver ejemplo).\n* En Scala se inicializa todo lo definido dentro del cuerpo de la clase al momento de instanciarla en un objeto (ver ejemplo).\n* Las clases de Scala estÃ¡n pensadas para escribir una mÃ­nima cantidad de cÃ³digo. Es por ello que los parÃ¡metros de la clase se convierten automÃ¡ticamente en atributos de solo lectura o lectura/escritura anteponiendo `val` y `var`.\n\n---\n\n* **Case Classes**: Son clases igual que las vistas pero exportan sus parÃ¡metros para proveer **pattern matching** (igual que en el lenguaje Haskell).\n\nPara mÃ¡s informaciÃ³n ver:\n* [DocumentaciÃ³n Scala sobre case clases](http://docs.scala-lang.org/tutorials/tour/case-classes).\n* [Introduccion a tipos algebraicos en Scala](http://tpolecat.github.io/presentations/algebraic_types.html).\n\n---\n\n* **Objetos Singletones:** Se usan cuando se quiere definir una unidad (mÃ³dulo) que contenga una serie de mÃ©todos y valores agrupados.\n* Son una sola instancia de una clase por lo que se aplica todo lo que vimos sobre clases.\n* Se usan tambiÃ©n para crear un ejecutable autÃ³nomo agregando un mÃ©todo `main`.\n* La inicializaciÃ³n se produce al momento de acceder un mÃ©todo o atributo.\n\nPara mÃ¡s informaciÃ³n ver:\n* [DocumentaciÃ³n Scala sobre objetos singletÃ³n](http://docs.scala-lang.org/tutorials/tour/singleton-objects).\n\n\n-----\n######1: Ver [Principio de acceso uniforme](http://en.wikipedia.org/wiki/Uniform_access_principle).\n","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":6,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>&nbsp;</p>\n<ul>\n<li>Las clases en Scala definen sus atributos con <code>val</code> (solo lectura) o <code>var</code> (lectura/escritura).</li>\n<li>Los mÃ©todos se definen con <code>def</code> en la forma que ya vimos.</li>\n<li>Notar en el ejemplo que el acceso a los atributos y mÃ©todos es uniforme lo que permite cambiar la implementaciÃ³n sin cambiar el cÃ³digo que lo usa<sup>1</sup>.</li>\n<li>Para declarar metodos o variables privadas se antepone la palabra clave <code>private</code> (ver ejemplo).</li>\n<li>En Scala se inicializa todo lo definido dentro del cuerpo de la clase al momento de instanciarla en un objeto (ver ejemplo).</li>\n<li>Las clases de Scala estÃ¡n pensadas para escribir una mÃ­nima cantidad de cÃ³digo. Es por ello que los parÃ¡metros de la clase se convierten automÃ¡ticamente en atributos de solo lectura o lectura/escritura anteponiendo <code>val</code> y <code>var</code>.</li>\n</ul>\n<hr />\n<ul>\n<li><strong>Case Classes</strong>: Son clases igual que las vistas pero exportan sus parÃ¡metros para proveer <strong>pattern matching</strong> (igual que en el lenguaje Haskell).</li>\n</ul>\n<p>Para mÃ¡s informaciÃ³n ver:</p>\n<ul>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/case-classes\">DocumentaciÃ³n Scala sobre case clases</a>.</li>\n<li><a href=\"http://tpolecat.github.io/presentations/algebraic_types.html\">Introduccion a tipos algebraicos en Scala</a>.</li>\n</ul>\n<hr />\n<ul>\n<li><strong>Objetos Singletones:</strong> Se usan cuando se quiere definir una unidad (mÃ³dulo) que contenga una serie de mÃ©todos y valores agrupados.</li>\n<li>Son una sola instancia de una clase por lo que se aplica todo lo que vimos sobre clases.</li>\n<li>Se usan tambiÃ©n para crear un ejecutable autÃ³nomo agregando un mÃ©todo <code>main</code>.</li>\n<li>La inicializaciÃ³n se produce al momento de acceder un mÃ©todo o atributo.</li>\n</ul>\n<p>Para mÃ¡s informaciÃ³n ver:</p>\n<ul>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/singleton-objects\">DocumentaciÃ³n Scala sobre objetos singletÃ³n</a>.</li>\n</ul>\n<hr />\n<h6>1: Ver <a href=\"http://en.wikipedia.org/wiki/Uniform_access_principle\">Principio de acceso uniforme</a>.</h6>\n"}]},"apps":[],"jobName":"paragraph_1503165523081_-100199302","id":"20160818-202628_1268617587","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4494"},{"title":"DefiniciÃ³n de una clase","text":"//Clase con una variable de solo lectura y un mÃ©todo\nclass Persona(nombre:String, apellido:String){  \n  val nombreCompleto = s\"$nombre $apellido\"\n  def saludo = {\n      count +=1\n      \"Hola $nombre $apellido!\"\n  }\n  def saludos(n:Int) = \"Hola \" * n + s\"$nombre $apellido!\"\n  private var count: Int = 0\n  def verCount = count\n}  \nval p = new Persona(\"Oso\",\"Fumarola\")\nprintln(p.saludo)  \nprintln(p.saludos(3))  \nprintln(p.nombreCompleto)\n//p.nombreCompleto = \"hola\" // Atributo solo lectura, da error\n\np.saludo\np.verCount","dateUpdated":"2017-08-19T17:16:02-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523081_-100199302","id":"20160818-202628_1911910324","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4495","user":"anonymous","dateFinished":"2017-08-19T17:16:02-0300","dateStarted":"2017-08-19T17:16:02-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Persona\n\np: Persona = Persona@24987265\nHola $nombre $apellido!\nHola Hola Hola Oso Fumarola!\nOso Fumarola\n\nres309: String = Hola $nombre $apellido!\n\nres310: Int = 2\n"}]}},{"title":"Inicializacion","text":"import scala.collection.mutable\n\nclass Prueba{\n      val set = new mutable.HashSet[Any] //TIRA ERROR\n      println(\"Inicializando!!!\")\n      set += \"Esto es un string\"  \n      set += 732                 \n      set += 'c'                 \n      set += true                \n      \n\n      def doSomething { println(\"Ya se inicializo el objeto pru!\") }\n    }\n\nval pru = new Prueba\n\npru.doSomething\n\nprintln(pru.set)\n\nval pru2 = new Prueba","dateUpdated":"2017-08-19T19:43:43-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523082_-99045055","id":"20160818-202628_83801003","dateCreated":"2017-08-19T14:58:43-0300","status":"ERROR","progressUpdateIntervalMs":500,"$$hashKey":"object:4496","user":"anonymous","dateFinished":"2017-08-19T19:43:43-0300","dateStarted":"2017-08-19T19:43:43-0300","results":{"code":"ERROR","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\n\n\n<console>:15: error: not found: value mutable\n             val set = new mutable.HashSet[Any] //TIRA ERROR\n                           ^\n"}]}},{"title":"ParÃ¡metros automÃ¡ticos","text":"class Persona(val nombre:String, var apellido:String)\n\nval p = new Persona(\"Oso\",\"Fumarola\")\nprintln(p.nombre)  \nprintln(p.apellido)  \np.apellido = \"Yogui\"\nprintln(p.apellido)","dateUpdated":"2017-08-19T19:22:12-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523082_-99045055","id":"20160818-202628_658870454","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4497","user":"anonymous","dateFinished":"2017-08-19T19:22:13-0300","dateStarted":"2017-08-19T19:22:12-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Persona\n\np: Persona = Persona@131c4eb9\nOso\nFumarola\n\np.apellido: String = Yogui\nYogui\n"}]}},{"title":"Case Classes","text":"abstract class Mascota // El tipo de todos los constructores que siguen\n\ncase class Gato(nombre: String) extends Mascota\ncase class Pez(nombre: String) extends Mascota\ncase class Perro(nombre: String, edad: Int) extends Mascota\n\nval catulo: Mascota = Gato(\"Catulo\")\n\ndef hola(p: Mascota): String = \n  p match {\n    case Gato(n)      => \"Miau \" + n + \"!\"\n    case Pez(n)       => \"Hola pez \" + n + \".\"    \n    case Perro(n, _)  => \"Hola \" + n + \".\"    \n  }\nhola(catulo)","dateUpdated":"2017-08-19T19:42:02-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":6,"results":{},"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523083_-99429804","id":"20160818-202628_434711538","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4498","user":"anonymous","dateFinished":"2017-08-19T19:42:02-0300","dateStarted":"2017-08-19T19:42:02-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Mascota\n\ndefined class Gato\n\ndefined class Pez\n\ndefined class Perro\n\ncatulo: Mascota = Gato(Catulo)\n\nhola: (p: Mascota)String\n\nres373: String = Miau Catulo!\n"}]}},{"title":"Objetos Singletones","text":"import scala.collection.mutable\n\nobject OPrueba{\n      val set = new mutable.HashSet[Any]\n      println(\"Inicializando!!!\")\n      set += \"Esto es un string\"  // add un string\n      set += 732                 // add un number\n      set += 'c'                 // add un character\n      set += true                // add un booleano\n      \n\n      def doSomething { println(\"Ya se inicializÃ³.\") }\n    }\n    \nprintln(OPrueba.set)\nprintln(\"TodavÃ­a no se inicializÃ³\")\nOPrueba.doSomething\n\nprintln(OPrueba.set)","dateUpdated":"2017-08-19T19:42:39-0300","config":{"enabled":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":6,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523083_-99429804","id":"20160818-202628_391181019","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4499","user":"anonymous","dateFinished":"2017-08-19T19:42:39-0300","dateStarted":"2017-08-19T19:42:39-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\ndefined object OPrueba\nInicializando!!!\nSet(c, 732, Esto es un string, true)\nTodavÃ­a no se inicializÃ³\nYa se inicializÃ³.\nSet(c, 732, Esto es un string, true)\n"}]}},{"text":"%md ##MÃ¡s sobre Scala\n\nEste tutorial cubre solo los conceptos bÃ¡sicos del lenguaje Scala.\nPara un conocimiento mÃ¡s completo se recomienda leer: \n* [10 Scala One Liners to Impress Your Friends](https://gist.github.com/mkaz/d11f8f08719d6d27bab5).\n* [ConversiÃ³n implÃ­cita](http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html) (complicado pero Ãºtil).\n* [A Tour of Scala](http://docs.scala-lang.org/tutorials/tour/tour-of-scala).\n","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>MÃ¡s sobre Scala</h2>\n<p>Este tutorial cubre solo los conceptos bÃ¡sicos del lenguaje Scala.\n<br  />Para un conocimiento mÃ¡s completo se recomienda leer:</p>\n<ul>\n<li><a href=\"https://gist.github.com/mkaz/d11f8f08719d6d27bab5\">10 Scala One Liners to Impress Your Friends</a>.</li>\n<li><a href=\"http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html\">ConversiÃ³n implÃ­cita</a> (complicado pero Ãºtil).</li>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/tour-of-scala\">A Tour of Scala</a>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503165523084_-101353549","id":"20160818-202628_1194782072","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4500"},{"title":"FIN","text":"println(\"\"\"%html\n<script>\n    var heads = document.getElementsByTagName('h2');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        inner = inner.replace(/^[\\W\\d]+/, \"\");\n        heads[i].innerHTML = (i+1) + \".- \" + inner;\n        i++\n    }\n</script>\n\"\"\")","dateUpdated":"2017-08-19T19:45:59-0300","config":{"enabled":true,"title":true,"tableHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/scala","editorHide":false,"colWidth":12,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<script>\n    var heads = document.getElementsByTagName('h2');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        inner = inner.replace(/^[\\W\\d]+/, \"\");\n        heads[i].innerHTML = (i+1) + \".- \" + inner;\n        i++\n    }\n</script>\n\n"}]},"apps":[],"jobName":"paragraph_1503165523084_-101353549","id":"20160818-202628_1129453015","dateCreated":"2017-08-19T14:58:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4501","user":"anonymous","dateFinished":"2017-08-19T19:46:00-0300","dateStarted":"2017-08-19T19:45:59-0300"},{"text":"","dateUpdated":"2017-08-19T14:58:43-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorHide":false,"colWidth":12,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503165523085_-101738298","id":"20160818-202628_1736609851","dateCreated":"2017-08-19T14:58:43-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4502"}],"name":"Tutorial Scala parte 2","id":"2CR2ANNSZ","angularObjects":{"2CRBJ1TRK:shared_process":[],"2CQ6E5PGQ:shared_process":[],"2CRKEY1QU:shared_process":[],"2CRUJFVZ8:shared_process":[],"2CS97UD25:shared_process":[],"2CQXJMN8C:shared_process":[],"2CPYT3M2U:shared_process":[],"2CSHR5Z2N:shared_process":[],"2CSAYAARD:shared_process":[],"2CQYNJRPB:shared_process":[],"2CSRCJNV5:shared_process":[],"2CQNUZHKK:shared_process":[],"2CQYHV85D:shared_process":[],"2CQ67YZNF:shared_process":[],"2CQ84C23F:shared_process":[],"2CSMN7B9W:shared_process":[],"2CPTEBNRV:shared_process":[],"2CS6Z5AX2:shared_process":[],"2CRCN644M:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}