{"paragraphs":[{"text":"val baseDir=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/03_rdd_notebook\"\nprint(\"\"\"%html\n<center>\n    <h1>ProgramaciÃ³n Distribuida sobre Grandes VolÃºmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de MatemÃ¡tica AstronomÃ­a FÃ­sica y ComputaciÃ³n\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de CÃ³rdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> DamiÃ¡n Barsotti  </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n\"\"\")\n","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/scala","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<center>\n    <h1>ProgramaciÃ³n Distribuida sobre Grandes VolÃºmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de MatemÃ¡tica AstronomÃ­a FÃ­sica y ComputaciÃ³n\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de CÃ³rdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> DamiÃ¡n Barsotti  </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n"}]},"apps":[],"jobName":"paragraph_1503544201294_265973309","id":"20160720-131723_1132815368","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:198"},{"text":"%md\n# PrÃ¡ctico 1 \n\n## MapReduce\n\nEn este prÃ¡ctico se desarrollarÃ¡n ejercicios para implementar algunos algoritmos MapReduce. AdemÃ¡s se practicarÃ¡ la construcciÃ³n de programas en Scala.\nPara hacer el prÃ¡ctico tener en cuenta:\n* Se recomienda fuertemente haber hecho el tutorial de Scala.\n* Para correr los programa debe usar **[`Shift`]-[`Enter`]** o cliquear el triangulito arriba a la derecha de la celda (RUN).\n* Para hacer copy and paste desde el notebook seleccionar con **[`Ctrl`]-[flechitas]** y hacer **[`Ctrl`]-[`c`]** y **[`Ctrl`]-[`v`]**.\n\n","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>PrÃ¡ctico 1</h1>\n<h2>MapReduce</h2>\n<p>En este prÃ¡ctico se desarrollarÃ¡n ejercicios para implementar algunos algoritmos MapReduce. AdemÃ¡s se practicarÃ¡ la construcciÃ³n de programas en Scala.\n<br  />Para hacer el prÃ¡ctico tener en cuenta:</p>\n<ul>\n<li>Se recomienda fuertemente haber hecho el tutorial de Scala.</li>\n<li>Para correr los programa debe usar <strong>[<code>Shift</code>]-[<code>Enter</code>]</strong> o cliquear el triangulito arriba a la derecha de la celda (RUN).</li>\n<li>Para hacer copy and paste desde el notebook seleccionar con <strong>[<code>Ctrl</code>]-[flechitas]</strong> y hacer <strong>[<code>Ctrl</code>]-[<code>c</code>]</strong> y <strong>[<code>Ctrl</code>]-[<code>v</code>]</strong>.</li>\n</ul>\n"}]},"apps":[],"jobName":"paragraph_1503544201297_275592031","id":"20160615-144959_2134148107","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:199"},{"text":"%md\n### ImplementaciÃ³n naif del patrÃ³n MapReduce\n\nA continuaciÃ³n se darÃ¡ una implementaciÃ³n muy simple del patrÃ³n en Scala. La misma corre solo en una mÃ¡quina, sin file system distribuido y solo nos servirÃ¡ para practicar su uso.\nLea el cÃ³digo y trate de entenderlo. Comparelo tambiÃ©n con la presentaciÃ³n en clase del tema. Cualquier duda consulte un docente.\n","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>ImplementaciÃ³n naif del patrÃ³n MapReduce</h3>\n<p>A continuaciÃ³n se darÃ¡ una implementaciÃ³n muy simple del patrÃ³n en Scala. La misma corre solo en una mÃ¡quina, sin file system distribuido y solo nos servirÃ¡ para practicar su uso.<br/>Lea el cÃ³digo y trate de entenderlo. Comparelo tambiÃ©n con la presentaciÃ³n en clase del tema. Cualquier duda consulte un docente.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201299_276361529","id":"20160615-145043_1018834183","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:200"},{"text":"// Funcion map comun pero que devuelve lista de pares (clave,valor)\ndef elMap[Kin,Vin,Kout,Vout]\n    (datosIn: List[(Kin,Vin)])\n    (fmap : (Kin,Vin) => List[(Kout,Vout)])\n    : List[(Kout,Vout)]\n    = datosIn.flatMap(kv => fmap(kv._1,kv._2)) // Cannot use just f, something wierd with implicits\n\n// Agrupa los valores que tienen clave comun\ndef agrupa[Kout,Vout]\n    (kvs : List[(Kout,Vout)])\n    : Map[Kout,List[Vout]]\n    = kvs.groupBy(_._1).mapValues(_.unzip._2)\n\n//    = kvs.groupBy(_._1).mapValues(_.map(_.2))\n\n// Para cada clave aplico una operacion a su lista de valores\ndef reduce[Kout,Vout,VFin]\n    (kvss : Map[Kout,List[Vout]])\n    (freduce : (Kout,  List[Vout]) => VFin)\n    : List[VFin]\n    = kvss.map({case (k,vs) => freduce(k,vs)}).toList\n\n//Junto todo\ndef mapReduce[Kin,Vin,Kout,Vout,VFin]\n    (datosIn: List[(Kin,Vin)])\n    (fmap : (Kin,Vin) => List[(Kout,Vout)])\n    (freduce : (Kout,  List[Vout]) => VFin)\n    : List[VFin]\n    = {\n        val resMap = elMap (datosIn) (fmap)\n        val resAgrupo  = agrupa(resMap)\n        val resReduce = reduce (resAgrupo) (freduce)\n        return resReduce\n    }","user":"anonymous","dateUpdated":"2017-08-28T19:44:08-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorMode":"ace/mode/scala","editorSetting":{"language":"scala"},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nelMap: [Kin, Vin, Kout, Vout](datosIn: List[(Kin, Vin)])(fmap: (Kin, Vin) => List[(Kout, Vout)])List[(Kout, Vout)]\n\nagrupa: [Kout, Vout](kvs: List[(Kout, Vout)])Map[Kout,List[Vout]]\n\nreduce: [Kout, Vout, VFin](kvss: Map[Kout,List[Vout]])(freduce: (Kout, List[Vout]) => VFin)List[VFin]\n\nmapReduce: [Kin, Vin, Kout, Vout, VFin](datosIn: List[(Kin, Vin)])(fmap: (Kin, Vin) => List[(Kout, Vout)])(freduce: (Kout, List[Vout]) => VFin)List[VFin]\n"}]},"apps":[],"jobName":"paragraph_1503544201300_274437785","id":"20160615-145341_501086069","dateCreated":"2017-08-24T00:10:01-0300","dateStarted":"2017-08-28T19:44:08-0300","dateFinished":"2017-08-28T19:44:09-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:201"},{"text":"%md\n### PequeÃ±o ejemplo de uso\n\nA continuaciÃ³n se verÃ¡ la implementaciÃ³n em MapReduce del algoritmo que encuentra la cantidad de apariciones de cada letra (visto en clase).\nPruebe ejecutarlo llamando a la funciÃ³n `countChar` con un `String` cualquiera.","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>PequeÃ±o ejemplo de uso</h3>\n<p>A continuaciÃ³n se verÃ¡ la implementaciÃ³n em MapReduce del algoritmo que encuentra la cantidad de apariciones de cada letra (visto en clase).<br/>Pruebe ejecutarlo llamando a la funciÃ³n <code>countChar</code> con un <code>String</code> cualquiera.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201302_275207283","id":"20160615-150406_526670902","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:202"},{"text":"// Cuento cantidad de veces que aparece cada letra\n// ===============================================\ndef countChar (str: String) = {\n    val datos = str.toList.map(c => ((),c))\n    val fmap = (_ : Unit, c : Char) => List((c,1))\n    val freduce = (c: Char, vs: List[Int]) => (c,vs.fold (0) (_+_))\n    mapReduce (datos) (fmap) (freduce)\n}","user":"anonymous","dateUpdated":"2017-08-28T19:44:13-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"results":{},"editorMode":"ace/mode/scala","editorSetting":{"language":"scala"},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ncountChar: (str: String)List[(Char, Int)]\n"}]},"apps":[],"jobName":"paragraph_1503544201303_274822534","id":"20160615-151707_1876187925","dateCreated":"2017-08-24T00:10:01-0300","dateStarted":"2017-08-28T19:44:13-0300","dateFinished":"2017-08-28T19:44:13-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:203"},{"text":"%md\n### Ejercicio ~\n\nEn la celda siguiente modifique el programa anterior para que tome un archivo en vez de un string.\nLa idea es que el `map` trabaje sobre cada linea de texto (no sobre cada caracter).\nNo se puede usar el programa anterior.\nA continuaciÃ³n se muestra un esqueleto del programa que debe completar programando las funciones `fmap` y `freduce`:\n","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~</h3>\n<p>En la celda siguiente modifique el programa anterior para que tome un archivo en vez de un string.<br/>La idea es que el <code>map</code> trabaje sobre cada linea de texto (no sobre cada caracter).<br/>No se puede usar el programa anterior.<br/>A continuaciÃ³n se muestra un esqueleto del programa que debe completar programando las funciones <code>fmap</code> y <code>freduce</code>:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201304_272898789","id":"20160615-152433_20160637","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:204"},{"text":"def countCharFile (filePath: String) = {\n    \nimport scala.io.Source\nimport collection.mutable\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n    val fmap = (_ : Unit, l : String) =>  {\n            val parcial : mutable.ListBuffer[(Char,Int)] = mutable.ListBuffer()\n            for (c <- l) parcial ++= List((c,1))\n            val lista = List() ++ parcial\n            lista\n    }\n    val freduce = (c: Char, vs: List[Int]) =>  (c,vs.fold (0) (_+_))\n    mapReduce (datos) (fmap) (freduce)\n}","user":"anonymous","dateUpdated":"2017-08-28T19:44:19-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":12,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ncountCharFile: (filePath: String)List[(Char, Int)]\n"}]},"apps":[],"jobName":"paragraph_1503544201306_273668287","id":"20160615-154328_239768480","dateCreated":"2017-08-24T00:10:01-0300","dateStarted":"2017-08-28T19:44:19-0300","dateFinished":"2017-08-28T19:44:19-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:205"},{"text":"%md\n### Ejercicio ~ (wordCount)\n\nHacer un programa que calcule la cantidad de veces que aparece cada palabra (no vacÃ­a) en un archivo.\nA continuaciÃ³n se muestra un esqueleto del programa que debe completar programando las funciones `fmap` y `freduce`.\n\n#### Ayuda\n\n* Para dividir un `String` en palabras se puede usar el mÃ©todo `split`.\n* Para filtrar elementos de una lista se puede usar el mÃ©todo `filter`. \n* Para ver si un `String` no es vacÃ­o se puede usar `! _.isEmpty`","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (wordCount)</h3>\n<p>Hacer un programa que calcule la cantidad de veces que aparece cada palabra (no vacÃ­a) en un archivo.<br/>A continuaciÃ³n se muestra un esqueleto del programa que debe completar programando las funciones <code>fmap</code> y <code>freduce</code>.</p>\n<h4>Ayuda</h4>\n<ul>\n  <li>Para dividir un <code>String</code> en palabras se puede usar el mÃ©todo <code>split</code>.</li>\n  <li>Para filtrar elementos de una lista se puede usar el mÃ©todo <code>filter</code>.</li>\n  <li>Para ver si un <code>String</code> no es vacÃ­o se puede usar <code>! _.isEmpty</code></li>\n</ul>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201307_273283538","id":"20160616-110119_1095838749","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:206"},{"text":"def wordCount (filePath: String) = {\n\nimport scala.io.Source\nimport collection.mutable\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n\n    val fmap = (_ : Unit, l : String) =>  {\n            val palabras = l.split(\" \")\n            val parcial : mutable.ListBuffer[(String,Int)] = mutable.ListBuffer()\n            for (w <- palabras) { if (!w.isEmpty) parcial ++= List((w,1)) }\n            val lista = List() ++ parcial\n            lista\n    }\n    val freduce = (w: String, vs: List[Int]) => (w,vs.fold (0) (_+_))\n\n    mapReduce (datos) (fmap) (freduce)\n}","user":"anonymous","dateUpdated":"2017-08-28T19:44:23-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":12,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nwordCount: (filePath: String)List[(String, Int)]\n"}]},"apps":[],"jobName":"paragraph_1503544201309_270975045","id":"20160616-110138_1909742592","dateCreated":"2017-08-24T00:10:01-0300","dateStarted":"2017-08-28T19:44:23-0300","dateFinished":"2017-08-28T19:44:23-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:207"},{"text":"%md\n### Ejercicio ~ (amigos en comÃºn)\n\nDada una lista de tuplas, donde el primer elemento es una persona y el segundo una lista de sus amigos, hacer un programa con `mapReduce` que devuelve la lista de amigos en comÃºn de todos los pares de **amigos** posibles.\nLa lista de amigos se almacena de la siguiente forma:\n```scala\nval amigosDe = List(  (\"A\", List(\"B\", \"C\", \"D\"))\n                    , (\"B\", List(\"A\", \"C\", \"D\", \"E\"))\n                    , (\"C\", List(\"A\", \"B\", \"D\", \"E\"))\n                    , (\"D\", List(\"A\", \"B\", \"C\", \"E\"))\n                    , (\"E\", List(\"B\", \"C\", \"D\"))      )\n```\nVer que la relaciÃ³n de amistad tiene que ser simÃ©trica.\n#### Ayuda\nPara cada par `(p,ams)` de la lista de entrada la funciÃ³n `map` puede devolver todas las tuplas posible `({p,am},ams)` donde `{p,am}` es un conjunto de dos persona y `am` es un elemento de `ams`.\nVer que en estos resultados deben aparecer exactamente dos tuplas cuyos primeros elementos (conjunto `{p,am}`) son iguales.\nA partir de esta observaciÃ³n los amigos en comÃºn son la intersecciÃ³n de las segundas componentes de ambas tuplas.\nA continuaciÃ³n se da un esqueleto del programa a completar:\n","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":409.05,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (amigos en comÃºn)</h3>\n<p>Dada una lista de tuplas, donde el primer elemento es una persona y el segundo una lista de sus amigos, hacer un programa con <code>mapReduce</code> que devuelve la lista de amigos en comÃºn de todos los pares de <strong>amigos</strong> posibles.<br/>La lista de amigos se almacena de la siguiente forma:</p>\n<pre><code class=\"scala\">val amigosDe = List(  (&quot;A&quot;, List(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;))\n                    , (&quot;B&quot;, List(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;))\n                    , (&quot;C&quot;, List(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;))\n                    , (&quot;D&quot;, List(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;E&quot;))\n                    , (&quot;E&quot;, List(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;))      )\n</code></pre>\n<p>Ver que la relaciÃ³n de amistad tiene que ser simÃ©trica.</p>\n<h4>Ayuda</h4>\n<p>Para cada par <code>(p,ams)</code> de la lista de entrada la funciÃ³n <code>map</code> puede devolver todas las tuplas posible <code>({p,am},ams)</code> donde <code>{p,am}</code> es un conjunto de dos persona y <code>am</code> es un elemento de <code>ams</code>.<br/>Ver que en estos resultados deben aparecer exactamente dos tuplas cuyos primeros elementos (conjunto <code>{p,am}</code>) son iguales.<br/>A partir de esta observaciÃ³n los amigos en comÃºn son la intersecciÃ³n de las segundas componentes de ambas tuplas.<br/>A continuaciÃ³n se da un esqueleto del programa a completar:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201310_272129291","id":"20160616-144311_939960850","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:208"},{"text":"val amigosDe = List(  (\"A\", List(\"B\", \"C\", \"D\"))\n                    , (\"B\", List(\"A\", \"C\", \"D\", \"E\"))\n                    , (\"C\", List(\"A\", \"B\", \"D\", \"E\"))\n                    , (\"D\", List(\"A\", \"B\", \"C\", \"E\"))\n                    , (\"E\", List(\"B\", \"C\", \"D\"))      )\n                    \ndef amigosEnComun(ade: List[(String,List[String])]) = {\n    import collection.mutable\n    \n    val fmap = (nombre : String, amigos: List[String]) => {\n        val parcial : mutable.ListBuffer[(Set[String],List[String])] = mutable.ListBuffer()\n        for (otro <- ade) {\n            if (amigos.contains(otro._1)) {\n                val elem = (Set(nombre ,otro._1),amigos)\n                    parcial += elem\n            }\n        }\n        val lista = List() ++ parcial\n        lista\n    }\n    val freduce = (s: Set[String], amigs: List[List[String]]) => { \n        val inter = amigs(0).intersect(amigs(1)) \n        (s,inter)\n    }\n    mapReduce (ade) (fmap) (freduce)\n}\n//amigosEnComun(amigosDe)","user":"anonymous","dateUpdated":"2017-08-28T19:44:29-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":12,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\namigosDe: List[(String, List[String])] = List((A,List(B, C, D)), (B,List(A, C, D, E)), (C,List(A, B, D, E)), (D,List(A, B, C, E)), (E,List(B, C, D)))\n\namigosEnComun: (ade: List[(String, List[String])])List[(Set[String], List[String])]\n"}]},"apps":[],"jobName":"paragraph_1503544201312_257508833","id":"20160616-144334_1113097282","dateCreated":"2017-08-24T00:10:01-0300","dateStarted":"2017-08-28T19:44:29-0300","dateFinished":"2017-08-28T19:44:29-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:209"},{"text":"%md\n### Ejercicio ~ (word co-ocurrencia)\nEn el siguiente ejercicio hay que construir la matriz de *co-ocurrencia* de palabras en una misma linea. Esta es una matriz simÃ©trica `n*n` donde `n` es el nÃºmero de palabras (sin repeticiÃ³n) en un texto. Para cada par de palabres (fila y columna de la matriz) se cuenta la cantidad de veces que ocurren ambas en una misma linea.\n\n#### Ayuda\nSe puede hacer que la funciÃ³n `fmap` devuelva los pares ordenados de palabras en una misma linea con un contador igual a `1`. Por ejemplo, en la linea `w1 w2 w3 w1` la funciÃ³n producirÃ¡: \n`(w1,w2):1, (w1, w3):1, (w1,w1):1, (w2,w3):1, (w1,w2):1, (w1,w3):1`\n\nLa funciÃ³n `freduce` recolectarÃ­a estos valores para llenar cada elemento de la matriz.\n\nA continuaciÃ³n se da un esqueleto del programa a completar:","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (word co-ocurrencia)</h3>\n<p>En el siguiente ejercicio hay que construir la matriz de <em>co-ocurrencia</em> de palabras en una misma linea. Esta es una matriz simÃ©trica <code>n*n</code> donde <code>n</code> es el nÃºmero de palabras (sin repeticiÃ³n) en un texto. Para cada par de palabres (fila y columna de la matriz) se cuenta la cantidad de veces que ocurren ambas en una misma linea.</p>\n<h4>Ayuda</h4>\n<p>Se puede hacer que la funciÃ³n <code>fmap</code> devuelva los pares ordenados de palabras en una misma linea con un contador igual a <code>1</code>. Por ejemplo, en la linea <code>w1 w2 w3 w1</code> la funciÃ³n producirÃ¡:<br/><code>(w1,w2):1, (w1, w3):1, (w1,w1):1, (w2,w3):1, (w1,w2):1, (w1,w3):1</code></p>\n<p>La funciÃ³n <code>freduce</code> recolectarÃ­a estos valores para llenar cada elemento de la matriz.</p>\n<p>A continuaciÃ³n se da un esqueleto del programa a completar:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201314_258278331","id":"20160616-165559_153544464","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:210"},{"text":"def wordCoOcurrence (filePath: String) = {\nimport scala.io.Source\nimport collection.mutable\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val init : mutable.ListBuffer[(List[String],Int)] = mutable.ListBuffer()\n    val inicializar = {for (lin <- lines) {\n                        val palabras = lin.split(\" \")\n                        for (pal <- palabras) {\n                           if (!pal.isEmpty) {\n                                for (lin2<-lines){\n                                    val palabras2 = lin2.split(\" \")\n                                    for (pal2 <- palabras2){\n                                        if (!pal2.isEmpty){\n                                            val elem = (List(pal,pal2),0)\n                                            init += elem\n                                        }\n                                    }\n                                    \n                                }\n                            }\n                        }\n             \n                    }\n    } //inicializamos todas las combinaciones de palabras en 0\n    val datos = lines.map(l => ((),l))\n    val fmap = (_ : Unit, l : String) =>  {\n            val palabras = l.split(\" \")\n            val parcial : mutable.ListBuffer[(List[String],Int)] = mutable.ListBuffer()\n            for (w1 <- palabras) { \n                if (!w1.isEmpty) {\n                    for (w2 <- palabras) {\n                        if (!w2.isEmpty) {\n                            val elem = (List(w1,w2),1)\n                            parcial += elem\n                        }\n                    }\n                    val repetido = (List(w1,w1),1)\n                    parcial -= repetido //eliminamos caso en que se cuenta a si mismo\n                }\n            }\n            val lista = List() ++ (parcial ++ init).distinct //filtramos las palabras repetidas.(si txt = \"hola hola hola\" => parcial = ((hola,hola),1)*3 y parcial.distinct=((hola,hola),1) \n            lista\n    }\n    val freduce = (par: List[String], vs: List[Int]) => (par,vs.fold (0) (_+_))\n    mapReduce (datos) (fmap) (freduce)\n}","user":"anonymous","dateUpdated":"2017-08-28T19:44:34-0300","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"colWidth":12,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nwordCoOcurrence: (filePath: String)List[(List[String], Int)]\n"}]},"apps":[],"jobName":"paragraph_1503544201315_257893582","id":"20160616-165637_456865360","dateCreated":"2017-08-24T00:10:01-0300","dateStarted":"2017-08-28T19:44:34-0300","dateFinished":"2017-08-28T19:44:35-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:211"},{"text":"%md\n### Ejercicio ~ (promedio)\n\nCon el programa `mapReduce` calcule el promedio de una lista de numeros.\n\nA continuaciÃ³n se da un esqueleto del programa a completar:\n","dateUpdated":"2017-08-24T00:10:01-0300","config":{"enabled":false,"tableHide":false,"results":{},"editorMode":"ace/mode/markdown","editorHide":true,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Ejercicio ~ (promedio)</h3>\n<p>Con el programa <code>mapReduce</code> calcule el promedio de una lista de numeros.</p>\n<p>A continuaciÃ³n se da un esqueleto del programa a completar:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1503544201316_255969838","id":"20170823-103411_1291391962","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:212"},{"text":"def Promedio (nums: List[Double]) : Double = {\n\n    val datos = nums.map(n => ((),n))\n    val fmap = (_ : Unit, n : Double) =>  {\n            val elem = (1,n)\n            val tupla: List[(Unit,(Int,Double))]= List(((),elem))\n            tupla\n    }\n    val freduce = (_ : Unit, tuplas: List[(Int,Double)]) => { \n            var total:Double = 0\n            var cant = 0\n            for (tupla <- tuplas){\n                total += tupla._2\n                cant+= tupla._1\n            } \n            val suma = (total, cant)\n            suma\n    }\n    val suma = mapReduce (datos) (fmap) (freduce)\n    val res = suma(0)\n    return res._1/res._2\n}\n//val test:List[Double] = List(1,3,5,10,1)\n//Promedio(test)\n","dateUpdated":"2017-08-28T19:44:42-0300","config":{"enabled":true,"results":{},"editorMode":"ace/mode/scala","editorSetting":{"language":"scala"},"colWidth":12},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503544201317_255585089","id":"20170823-103440_918535335","dateCreated":"2017-08-24T00:10:01-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:213","user":"anonymous","dateFinished":"2017-08-28T19:44:42-0300","dateStarted":"2017-08-28T19:44:42-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nPromedio: (nums: List[Double])Double\n"}]}},{"title":"FIN","text":"println(\"\"\"%html\n<script>\n    var heads = document.getElementsByTagName('h3');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\"Ejercicio\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(/Ejercicio (~|\\d+)/,\"Ejercicio \"+j);\n        }\n        i++\n    }\n</script>\n\"\"\")\n","dateUpdated":"2017-08-28T19:44:51-0300","config":{"enabled":true,"title":true,"tableHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorMode":"ace/mode/scala","editorHide":true,"editorSetting":{"language":"scala"},"colWidth":12},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<script>\n    var heads = document.getElementsByTagName('h3');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\"Ejercicio\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(/Ejercicio (~|\\d+)/,\"Ejercicio \"+j);\n        }\n        i++\n    }\n</script>\n\n"}]},"apps":[],"jobName":"paragraph_1503544201318_256739335","id":"20160616-171626_2027424644","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:214"},{"dateUpdated":"2017-08-24T00:10:01-0300","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1503544201319_256354586","id":"20160830-114323_344385570","dateCreated":"2017-08-24T00:10:01-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:215"}],"name":"Practico 1","id":"2CT6EUGGM","angularObjects":{"2CRBJ1TRK:shared_process":[],"2CQ6E5PGQ:shared_process":[],"2CRKEY1QU:shared_process":[],"2CRUJFVZ8:shared_process":[],"2CS97UD25:shared_process":[],"2CQXJMN8C:shared_process":[],"2CPYT3M2U:shared_process":[],"2CSHR5Z2N:shared_process":[],"2CSAYAARD:shared_process":[],"2CQYNJRPB:shared_process":[],"2CSRCJNV5:shared_process":[],"2CQNUZHKK:shared_process":[],"2CQYHV85D:shared_process":[],"2CQ67YZNF:shared_process":[],"2CQ84C23F:shared_process":[],"2CSMN7B9W:shared_process":[],"2CPTEBNRV:shared_process":[],"2CS6Z5AX2:shared_process":[],"2CRCN644M:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}